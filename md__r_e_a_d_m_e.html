<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CTStr: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CTStr
   </div>
   <div id="projectbrief">Turns string literals into unique types</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#CTStr: Compile-Time Strings</p>
<h2>5-Second Rundown</h2>
<p>If you just got here and you want the super short version, this is what this library lets you do: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;static_assert(std::is_same&lt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                           string_to_type(&quot;foo&quot;), </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                           std::integer_sequence&lt;char, &#39;f&#39;, &#39;o&#39;, &#39;o&#39;&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                          &gt;::value);</div>
</div><!-- fragment --><p>In other words, this lets you turn a quoted <code>"string"</code> into an <code>std::integer_sequence</code> which can be used in a template argument.</p>
<p>This is a tiny library. Literally just 1 important function/macro, 2 helper functions, and 2 settings macros all in one header file.</p>
<h2>Introduction</h2>
<p>C++ doesn't allow (inline) strings as template arguments. For example, it's impossible to do this: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;constexpr bool check_string(const char* str)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    // Do something with str here--make sure it&#39;s less than a certain length maybe.</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;template &lt;const char* str&gt;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void frob()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    static_assert(check_string(str), &quot;Can&#39;t use this string!&quot;);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // Do something with str</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;int main()</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    frob&lt;&quot;foo&quot;&gt;();      // Won&#39;t work</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    extern char str[];</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    frob&lt;str&gt;();        // Works, but is super ugly and requires the definition of str be somewhere else</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;char string[] = &quot;foo&quot;;</div>
</div><!-- fragment --><p> <code>static_assert</code> is awesome, and it's a shame that it's impossible really to make it work cleanly with string literals (among plenty of other things you could do with compile-time string literals).</p>
<p>This tiny library aims to solve that.</p>
<h2>How?</h2>
<p>C++ doesn't allow C-style strings as template arguments. But other things are fair game. Specifically the <code>integer_sequence</code> class. <code>integer_sequence</code> is a new class made possible with C++11 and made available in C++14. It's literally an empty class that just encodes a series of numbers in its type. <code>template &lt;typename T, T...Values&gt; class integer_sequence{};</code> is literally the whole definition of the class.</p>
<p>So what we're going to do is take a C-style string and put its characters into an <code>integer_sequence</code>. The end result will look like `integer_sequence&lt;char, 'f', 'o', 'o'&gt;`. But that is, as I'm sure anyone would agree, unbelievably annoying to type. 4-5 keystrokes per character. Awful. So we want a way to automate the process.</p>
<h2>Enter <code>string_to_type</code></h2>
<p>To solve our problem we'll use a handy macro that will take a string and spit out a type. Specifically that <code>integer_sequence</code> type I mentioned earlier. And that's it! That's all we need. The macro in question is <code>string_to_type</code>.</p>
<p>Usage is very simple: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;using SomeStringType = string_to_type(&quot;foo&quot;);            // SomeStringType is the same as integer_sequence&lt;char, &#39;f&#39;, &#39;o&#39;, &#39;o&#39;&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;std::cout &lt;&lt; ctstr::to_string&lt;SomeStringType&gt;();         // Because SomeStringType is in fact a type, you&#39;ll pass it as a template argument.</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;std::cout &lt;&lt; ctstr::to_string(SomeStringType{});         // ...But for convenience&#39;s sake this is also acceptable.</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;std::cout &lt;&lt; ctstr::to_string&lt;string_to_type(&quot;foo&quot;)&gt;();  // This is also fine. string_to_type can be used inline anywhere a normal template argument is expected.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;std::cout &lt;&lt; ctstr::to_string(string_to_type(&quot;foo&quot;){});  // And of course we have the convenient method as well.</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;using U32StringType = string_to_type(U&quot;F͆̆̊́͊ͯͯ̆̐̀̊̔̆̐ͬͮ̅öò&quot;);            // And of course this works too.  </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                                                         // The type is std::integer_sequence&lt;char32_t, ...&gt;.  </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                                                         // But watch out for combining characters!</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                                                         // This sequence is 20 integers long!</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                                                         // In fact, it could be longer depending on what normalization form the string&#39;s in.</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                                                         // In general, I&#39;d stay away from using Unicode strings for this reason.</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                                                         // You could get some unexpected (but totally legal) results.</div>
</div><!-- fragment --><p>So with the basics out of the way, let's say we wanted to rewrite our code above. We'd do this: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;template &lt;typename String&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;constexpr bool check_string()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    // Do something with String here--make sure it&#39;s less than a certain length maybe.</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // Remember that String is just an integer_sequence.  </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // You&#39;ll want to break out your functional programming techniques here.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;template &lt;typename String&gt;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;void frob()</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    static_assert(check_string&lt;String&gt;(), &quot;Can&#39;t use this string!&quot;);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    // Do something with String</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;int main()</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    frob&lt;string_to_type(&quot;foo&quot;)&gt;();      // THE IMPORTANT PART! LOOK HERE!</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment --><p>The changes, in order:</p><ol type="1">
<li><code>check_string</code> changed. It now takes a template parameter instead of a normal argument because we're going to be passing it types instead of objects.</li>
<li><code>frob</code> now takes a type parameter. We call it <code>String</code>, and when called correctly it will hold an <code>std::integer_sequence</code> of some kind.</li>
<li>We use <code>string_to_type</code> in our call to <code>frob</code>.</li>
</ol>
<p>But really the important part is the call to the <code>string_to_type</code> macro. As a reminder, this just takes your string, <code>"foo"</code>, and "explodes" it into individual characters which are all put into an <code>std::integer_sequence</code>. That integer sequence is the result. So when you call <code>frob&lt;string_to_type("foo")&gt;</code>, you're really calling `frob&lt;std::integer_sequence&lt;char, 'f', 'o', 'o'&gt;&gt;<code>. What you choose to do in</code>frob<code>with this</code>integer_sequence` is up to you.</p>
<h2>The gory details</h2>
<p>So I mentioned macros before and this is where things get...hairy. Thankfully C++11 introduced the notion of <code>constexpr</code> to make this whole library possible. Less thankfully constexpr is extremely limited in what it can do. In particular it cannot take constexpr arguments. What this means, more or less, is that the only thing we can use to build our type is the return values of functions. We cannot build part of our sequence in the function itself, because that requires a constant expression, and <code>constexpr</code> functions don't have any guarantee on the "constexpr-ness" of their arguments. The usual way to accept a "constexpr argument" is to take it as a template argument. And we'd totally do that! ...if strings could be taken as template arguments.</p>
<p>So we can't have a function that takes a string and returns an <code>std::integer_sequence</code> or any part of one is what I'm saying. It's just impossible. Instead we need a function that takes a single char and returns a part of an <code>std::integer_sequence</code>. A lot of these functions.</p>
<p>So what we do is create a macro. This macro basically looks like </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define macro(str) std::integer_sequence&lt;char, get_char(str, 0), get_char(str, 1), get_char(str, 2), ...&gt;</div>
</div><!-- fragment --><p> Though it's more sophisticated than that. For example, you can still do <code>string_to_type(U"foo")</code> and you'll get an <code>std::integer_sequence&lt;char32_t, ...&gt;</code>. There are also checks to make sure the string isn't too long.</p>
<p>"Too long?" So there's a maximum length on these strings. Since macros are way, way more limited than the actual C++ language itself what we basically do is repeat the <code>"get_char(str, X)"</code> pattern a gazillion times. The meaning of "gazillion" is, by default, 256, and can be changed by defining <code>CTSTR_MAX_STRING_SIZE</code> to be something else (just make sure it's a power of 2).</p>
<p>Anyway, if you try to make a string that's too long (so by default a string that's more than 256 characters), you'll get a <code>static_assert</code> failure, which is nice.</p>
<h2>An actual example</h2>
<p>This example acts as a (very simple) translation system. There's a function called <code>translate</code> that takes a string and a language and returns the translated string. There are also a bunch of overloaded <code>get_translation</code> functions, one for each combination of string and language. Which one is called is determined by overloading on the unique types of each string, and the unique type of each language.</p>
<p>The main advantage of this system is that there's a compile-time guarantee that you can't ask to translate a string that doesn't have a translation. If you try, you'll get an error.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{C++}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;CTStr/CTStr.hpp&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#include &lt;iostream&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#include &lt;cassert&gt;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;enum class language</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    english,</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    japanese</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;};</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;namespace detail</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;{</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    // Define a unique type for each language.</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    // You could also do &quot;struct english {}&quot; but I like this better because each language gets an ID.</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    using english  = std::integral_constant&lt;int, static_cast&lt;int&gt;(language::english)&gt;;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    using japanese = std::integral_constant&lt;int, static_cast&lt;int&gt;(language::japanese)&gt;;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    // What we&#39;re doing here is dispatching on tags, where the tags our our type&#39;d strings.</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    // All these get_translation functions are just overloaded on string &quot;type&quot; and language &quot;type&quot;.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    // So if we call get_translation(string_to_type(u8&quot;Hello!&quot;){}, english{}),</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    // we&#39;ll select the very first overloaded function.</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    // Translations into English follow</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    // Since we already have the strings here, we can just use to_string() to avoid duplicating them.</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    std::string get_translation(string_to_type(u8&quot;Hello!&quot;) s,                            english) { return ctstr::to_string(s); }</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    std::string get_translation(string_to_type(u8&quot;Please enter your name: \0 NORMAL&quot;) s, english) { return ctstr::to_c_string(s); }</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    std::string get_translation(string_to_type(u8&quot;Please enter your name: \0 POLITE&quot;) s, english) { return ctstr::to_c_string(s); }</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    std::string get_translation(string_to_type(u8&quot;It happened %0 times on %1/%2/%3&quot;) s,  english) { return ctstr::to_string(s); }</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    // Translations into Japanese follow.</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    // Note that we can abuse null characters to insert &quot;invisible&quot; differences between strings.</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    // This can be used if some string in English has multiple translations in another language.</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    // By sticking stuff after a null character, we make their types different,</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    // but nothing after the null character will be read (if we use to_c_string() instead of to_string()).</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    // Note how our &quot;Please enter your name:&quot; string is translated into two different strings here.</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    std::string get_translation(string_to_type(u8&quot;Hello!&quot;) s,                            japanese) { return u8&quot;こんにちは！&quot;; }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    std::string get_translation(string_to_type(u8&quot;Please enter your name: \0 NORMAL&quot;) s, japanese) { return u8&quot;名前を入力してください&quot;; }</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    std::string get_translation(string_to_type(u8&quot;Please enter your name: \0 POLITE&quot;) s, japanese) { return u8&quot;お名前をご入力して頂ければ幸いに存じます&quot;; }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    std::string get_translation(string_to_type(u8&quot;It happened %0 times on %1/%2/%3&quot;) s,  japanese) { return u8&quot;%3年%1月%2日に%0回起こりますた&quot;; }</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    // Catch-all that&#39;s guaranteed to have the lowest priority of all the get_translation functions.</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    // If we end up calling this function, it&#39;s because we don&#39;t have an actual translation.</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    // We give it a template parameter so we can get a static_assert out of it.</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    template &lt;typename T&gt;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    std::string get_translation(T, ...)</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        static_assert(!std::is_same&lt;T, T&gt;::value, &quot;There is no translation for this string, or not all possible translations for it have been defined yet.&quot;);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;// Given a string as a template parameter and a language, returns the string translated into that language.</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;template &lt;typename String&gt;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;std::string translate(language lang)</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    if (lang == language::english)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        return detail::get_translation(String{}, detail::english{});</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    else if (lang == language::japanese)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        return detail::get_translation(String{}, detail::japanese{});</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    else</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        assert(false &amp;&amp; &quot;Unknown language!&quot;);        // Will only get here if passed a language outside of the enum</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        return detail::get_translation(String{}, detail::english{});</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;int main(int argc, char* argv[])</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;{</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    // Remember: Non-ASCII characters won&#39;t look right in the console in Windows by default.</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    // On Windows either trust that the output is correct or pipe to a file.</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    std::cout &lt;&lt; translate&lt;string_to_type(u8&quot;Hello!&quot;)&gt;(language::english) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    std::cout &lt;&lt; translate&lt;string_to_type(u8&quot;Hello!&quot;)&gt;(language::japanese) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    std::cout &lt;&lt; translate&lt;string_to_type(u8&quot;Please enter your name: \0 NORMAL&quot;)&gt;(language::english) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    std::cout &lt;&lt; translate&lt;string_to_type(u8&quot;Please enter your name: \0 NORMAL&quot;)&gt;(language::japanese) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    // This would cause an error because we never defined that translation!</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    // But it would be a compile-time error, not a runtime error, which, again, is way better.</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    // std::cout &lt;&lt; translate&lt;string_to_type(u8&quot;Goodbye!&quot;)&gt;(language::japanese) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;}</div>
</div><!-- fragment --><h2>In Summary</h2>
<ul>
<li>Use <code>string_to_type("string")</code> to create an <code>std::integer_sequence</code> that contains the same characters as <code>"string"</code>.</li>
<li>All string types are supported, so <code>string_to_type(U"string")</code> works too.</li>
<li>This library only creates the strings. If you want things like string splitting, finding, etc. you'll want a library that operates on <code>std::integer_sequence</code>s. This is mostly a matter of practicality; there's no point in reinventing the wheel when other solutions exist already.</li>
<li>If your compiler/library doesn't support C++14 and so doesn't have <code>std::integer_sequence</code>, make your own and <code>#define</code> <code>CTSTR_SEQUENCE_TYPE</code> to be your custom type.</li>
<li><em>Be careful if you're using Unicode characters in your strings!</em> Seriously. If you know what Unicode Normalization Forms are, then you already know why. If you don't, then just save yourself the trouble of wondering why <code>static_assert(std::is_same&lt;string_to_type(U"á"), string_to_type(U"á")&gt;::value)</code> is failing and just stay away. (Protip: The first is <code>std::integer_sequence&lt;char32_t, 97, 769&gt;</code> and the second is <code>std::integer_sequence&lt;char32_t, 225&gt;</code>. Both are considered canonically equivilant but <code>std::is_same</code> has no way of knowing that.)</li>
<li>The default maximum size of a compile-time string is 0x100. Trying to create a string longer than that will result in a compile-time error. If you need longer strings, <code>#define</code> <code>CTSTR_MAX_STRING_SIZE</code> to be any power of 2 between 1 and 0x10000 (though keep in mind compiler performance when increasing the limit). </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
